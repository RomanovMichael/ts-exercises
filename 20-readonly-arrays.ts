// Typescript: Массивы только для чтения
// В разработке на JavaScript, где активно применяются функции высшего порядка, такие как map, filter и reduce, массивы меняются редко. Обычно вместо этого создаются новые.

// Технически JavaScript не может запретить изменять существующие массивы, поэтому ответственность за соблюдение этого правила лежит на программистах. В этом уроке разберем работу с массивами только для чтения.

// Использование неизменяемых массивов
// В TypeScript работа с неизменяемыми массивами встроена в систему типов. Чтобы гарантировать неизменяемость, массив помечается модификатором readonly:

// function process(numbers: readonly number[]) {
//   numbers.push(1); // Error!
// }
// В этом случае TypeScript выдает ошибку, что тип readonly number[] не содержит метода push.

// Модификатор readonly запрещает изменение массива, но не запрещает изменение объектов, которые находятся внутри массива:

// const items: readonly ({ key: string })[] = [{ key: 'value'}];
// items[0].key = 'another value'; // ok!
// Мы успешно изменили значение свойства key в объекте, который находится внутри массива.

// Модификатор readonly — синтаксический сахар. В случае массива readonly меняет тип Array на тип ReadonlyArray. Такая запись, как и Array<Type> улучшает читабельность кода, но в остальном не отличается от readonly Type[].

// Код выше можно было бы записать так:

// const items: ReadonlyArray<{ key: string }> = [{ key: 'value'}];
// Задание
// Реализуйте функцию reverse(), которая переворачивает массив. Технически она должна возвращать новый массив, в котором элементы расположены в обратном порядке. Используйте модификатор readonly для входящего массива. Не используйте встроенный метод reverse().

// reverse([1, 2, 8]); // [8, 2, 1]
// reverse([10, 33, 7, 0]); // [0, 7, 33, 10]


const reverse = (nums: readonly number[]): number[] => {
    const total: number[] = []
    nums.forEach(num => total.unshift(num))
    return total
}

function reverse1(coll: readonly number[]): number[] {
  return coll.map((_, index) => coll[coll.length - 1 - index]);
}